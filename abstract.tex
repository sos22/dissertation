\begin{abstract}
Various trends in computing mean that future software will be
increasingly parallel, which implies that concurrency bugs will be an
increasingly serious problem.  At present, such bugs are difficult for
programmers to understand and fix, largely because they tend to
reproduce in complex and unpredictable ways.  This dissertation
presents {\technique}, a suite of complementary techniques aimed at
discovering, characterising, reproducing, and ultimately fixing a
particular class of concurrency bugs.  These techniques require access
only to the program binary, and not to its source, and require minimal
manual intervention.  I evaluate {\implementation}, my prototype
implementation of {\technique}, experimentally, showing that it can
usefully be applied to real bugs in large existing software projects,
and characterising when it is likely to fail.  I then place
{\technique} in context by comparing it to existing approaches to
these problems, describing how it builds upon or complements these
other systems, before closing with a discussion of possible future
work and a summary of the conclusions drawn.

The core idea in {\technique} is the \gls{bugenforcer}: a co-program
which runs alongside a running program and gently shepherds its
execution towards a schedule which is likely to reproduce a particular
bug.  {\Technique} uses these both to weed out false positives
produced by its initial (highly conservative) static analysis and to
confirm properties of the bug needed to generate its fix.
\Glspl{bugenforcer} are also useful in their own right: as I show in
the evaluation, they can often reduce the time taken to reproduce a
bug by many orders of magnitude when compared to stress testing alone,
which would potentially be of great help to a programmer tasked with
understanding and eliminating some undesirable behaviour.  I describe
the \gls{bugenforcer} mechanism in detail, showing both how it works
and some of its more important weaknesses.

\todo{Could do with being a bit longer.}

\end{abstract}
