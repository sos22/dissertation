\chapter{Gaining control of a running program}
\label{sect:enforce:gain_control}

\todo{This is maybe a bit short to have its own chapter?}

The discussion of building crash enforcers in
\autoref{sect:reproducing_bugs} assumes that it can gain control of
the program at any point.  This section describes one possible way of
doing so.  The basic idea is quite simple: to replace some
instructions of the original program with branch instructions which
transfer control to the entry point of the plan interpreter.  This is
efficient and avoids unnecessarily modifying the program's state.
There is, however, a risk that the branch instruction will be larger
than the instruction at which the interpreter needs to gain control,
in which case the branch will corrupt the following instruction.  The
patching mechanism must ensure that the program never executes one of
these corrupted instructions\footnote{Instructions will only be
  corrupted like this on architectures which have variable-sized
  instructions, such as AMD64, but there is an analogous problem on
  fixed-size instruction architectures such as ARM or Alpha.  These
  architectures generally lack a single instruction capable of
  branching to any location in their address space, and so the patch
  might need to use several instructions to implement the branch,
  which has the same effect as just using a single very large branch
  instruction.}.

\begin{sanefig}
  \begin{displaymath}
    \textsc{PatchStrategy} = \left\{\begin{array}{rl}
    \mathit{Patch}: & \{\textsc{Instruction}\} \\
    \mathit{Cont}: & \{\textsc{Instruction}\} \\
    \mathit{MustInterpret}: & \{\textsc{Instruction}\}
    \end{array}\right\}
  \end{displaymath}
  \vspace{-12pt}
  \caption{The \textsc{PatchStrategy} type}
  \label{fig:patch_strategy_type}
\end{sanefig}

{\Implementation} represents solutions and partial solutions to the
patch problem using the \textsc{PatchStrategy} type, illustrated in
\autoref{fig:patch_strategy_type}:
\begin{itemize}
\item $\mathit{Patch}$ is the set of instructions in the original
  program which will be replaced with branch instructions.
\item $\mathit{Cont}$ is a set of instructions which are not patched
  themselves but which will be run in the interpreter anyway.
\item $\mathit{MustInterpret}$ is a set of instructions at which we
  must gain control but the strategy built so far is insufficient to
  do so.
\end{itemize}
A \textsc{PatchStrategy} is valid if it ensures that the program never
executes one of the corrupted instructions.  The empty strategy, in
which all of the sets are empty, representing the initial unpatched
program, is a valid strategy, but is also not very useful.  There are
three rules for transforming one valid strategy into another, or into
a set of others:
\begin{itemize}
\item
  $\textbf{Extend}(i)$ This rule extends the \textsc{PatchStrategy} by
  adding a new instruction $i$ to $\mathit{MustInterpret}$.
\item
  \textbf{PatchDirect} This rule transforms a \textsc{PatchStrategy}
  by removing an instruction $i$ from the $\mathit{MustInterpret}$ set
  and adding it to the $\mathit{Patch}$ one, so that the enforcer will
  gain control at $i$ by replacing $i$ with a branch to the
  interpreter.  This could potentially corrupt the instructions
  following $i$; if so, the corrupted instructions are added to
  $\mathit{MustInterpret}$.  This rule is only valid if the branch at
  instruction $i$ would not itself corrupt or be corrupted by one of
  the other instructions in the $\mathit{Patch}$ set.
\item
  \textbf{Prefix} This rule also removes an instruction $i$ from
  $\mathit{MustInterpret}$, but does not add it to $\mathit{Patch}$
  and hence will not replace the instruction with a branch.  The rule
  instead adds $i$ to $\mathit{Cont}$ and all of $i$'s predecessors to
  $\mathit{MustInterpret}$, so that the enforcer gains control before
  $i$ starts and then maintains control when the program branches to
  $i$.  This rule is only valid $i$ is not the first instruction in a
  function.
\end{itemize}

\todo{rewrite} {\Technique} uses these rules to explore the space of
valid \textsc{PatchStrategy}s, using the algorithm shown in
\autoref{fig:patch_search_algorithm}.  Starting from the empty
\textsc{PatchStrategy} (line 2), it considers each instruction at
which it must gain control in turn (line 3).  For each one, it adds
the instruction to the $\mathit{MustInterpret}$ set (line 4) and then
explores from there using the first two strategy generating rules
(lines 5 to 13) until it finds a strategy with an empty
$\mathit{MustInterpret}$ state (lines 7 to 9).  The algorithm then
loops again adding another instruction from $\mathit{gainControl}$ to
$\mathit{MustInterpret}$, and repeats until every instruction has been
added.

\begin{sanefig}
  \begin{algorithmic}[1]
    \Procedure{BuildPatchStrategy}{$\mathit{gainControl}$}
    \State {$\mathit{soln} \gets \textsc{PatchStrategy}(\mathit{Patch} = \{\}, \mathit{Cont} = \{\}, \mathit{MustInterpret} = \{\})$}
    \For {$i \in \mathit{gainControl}$}
      \State {$q \gets \queue{\textbf{Extend}(i)(\mathit{soln})}$}
      \While {\true}
        \State {$\mathit{s} \gets \mathit{pop}(q)$}
        \If {$s.\mathit{MustInterpret} = \{\}$}
          \State {$\mathit{soln} \gets s$}
          \State \textbf{break}
        \Else
          \State {$q \gets q + \mathbf{PatchDirect}(s) + \mathbf{Prefix}(s)$}
        \EndIf
      \EndWhile
    \EndFor
    \State \Return $\mathit{soln}$
    \EndProcedure
  \end{algorithmic}
  \caption{Patch search algorithm.  $\mathit{gainControl}$ is the set
    of instructions at which the enforcer must gain control of the
    program.  Not shown: {\implementation}'s implementation records
    all of the strategies which it has visited so far so as to avoid
    re-visiting them.}
  \label{fig:patch_search_algorithm}
\end{sanefig}

This algorithm, as stated, leaves the order in which
\textsc{PatchStrategy}s are removed from the queue ambiguous.  This
can sometimes have a large effect on the number of instructions which
must be executed in the interpreter, and hence on the performance
overheads of the patch.  It is hard to predict precisely how large an
impact a given strategy will have on performance without a detailed
model of the program's behaviour, but it can reasonably be
approximated to be proportional to the number of static instructions
affected, $|\mathit{Cont} \cup \mathit{Patch}|$.  {\Implementation}
will therefore always choose to expand the strategy where that
quantity is smallest, which usually causes it to find the strategy
which minimises the cost of patch\footnote{The result is only usually
  minimal, rather than guaranteed to be minimal, because the
  $\mathit{gainControl}$ set is processed incrementally, with no
  backtracking from one instruction to an earlier one, and so it might
  be that the first instruction processed produces a strategy which is
  incompatible with the optimal strategy for the second instruction.
  There is an alternative non-incremental version of the algorithm
  which starts by setting $\mathit{MustInterpret}$ to
  $\mathit{gainControl}$, rather than adding one instruction at a
  time, and that alternative version would be guaranteed to find the
  optimal solution.  On the other hand, the search process itself
  would be far more expensive, as it would attempt to explore from
  every $\mathit{gainControl}$ instruction simultaneously.  This would
  raise the cost from $O(nk)$ to $O(n^k)$, where $k =
  |\mathit{gainControl}|$ and $n/k$ is the cost of the current
  algorithm.  In practice, the algorithm given here rarely needs to
  add more than one or two instructions to the $\mathit{Cont}$ set
  anyway (see \autoref{sect:eval:genfix}), and so this would not be a
  good trade-off.}.

The condition on the \textbf{Prefix} rule, that the instruction must
not be the first one in a function, perhaps requires further
explanation.  The here is that functions in the main program might be
called from libraries, and the \gls{programmodel}\editorial{huh?} will
not be able to detect such calls unless they are observed during the
dynamic analysis phase.  Missing such a call would lead to the
algorithm producing an incorrect \textsc{PatchStrategy} which might
either fail to gain control when necessary or, worse, allow the
program to execute corrupted instructions, causing it to misbehave.
Simply disabling the \textbf{Prefix} rule at the start of a function
avoids the issue.

This can sometimes lead to the patch problem being unsolvable if the
entire function is smaller than a single branch instruction, as in
that case it will not be possible to patch the function without
corrupting the first instruction of the next function in the binary.
In that case, {\implementation} simply gives up and reports an error.
This is rarely a problem in practice, as very few functions are that
small without very aggressive compiler optimisations, and most
compilers, including gcc\cite[Section~3.10]{Stallman2010} and
LLVM\needCite{}, will at high optimisation levels pad functions to a
multiple of 16 bytes for performance reasons.

\todo{Not convinced I want this here.  Or in fact anywhere.}  An
alternative approach would be to take control of the program using
debug breakpoints rather than jump instructions.  These are either a
single byte (for the \verb|int3| instruction) or no bytes at all (for
debug registers), and so avoid the instruction clobbering problem.
This would work, but would have a couple of important disadvantages:

\begin{itemize}
\item
  Debug breakpoints are far slower than branches.  This might be
  important if the critical section is to be inserted on a
  particularly hot code path and has a side-condition which usually
  fails.
\item
  Using debug breakpoints in this way would interfere with any other
  debugger which the developer might want to use.  With a branch-style
  patch, standard debuggers work without modification for any part of
  the program which has not been patched, whereas a breakpoint-style
  patch requires extensive coordination between the debugger and the
  patch mechanism for either to work at all.
\item
  Breakpoint registers are of strictly limited number on most
  architectures (four, on x86).  This means that they can never
  provide a complete solution by themselves.
\end{itemize}

{\Implementation} therefore generates exclusively branch-style patches.
