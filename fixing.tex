\chapter{Fixing bugs}
\label{sect:fix_global_lock}

\newcommand{\one}{~\hspace{-1.2pt}1\hspace{3.0pt}~}

In addition to finding bugs, {\technique} can also be used to fix
them.  The technique used is, in essence, to introduce a new global
lock covering the relevant parts of the program's \gls{cfg},
preventing them from executing in parallel and preventing the
dangerous interleavings from occurring.  This chapter describes in
detail how this is done.

\section{Identifying critical sections}
\label{sect:fix:identify}

\begin{sanefig}
  \hspace{-5mm}\subfigure[][\gls{crashingthread}]{
    \texttt{
      \begin{tabular}{lll}
        1 & \multicolumn{2}{l}{ptr = complex\_local\_condition();}\\
        2 & \multicolumn{2}{l}{dptr = *ptr;}\\
        3 & \multicolumn{2}{l}{if (dptr != NULL) \{}\\
        4 & &dptr = *ptr1;\\
        5 & &*dptr = 5;\\
        6 & \multicolumn{2}{l}{\}}\\
      \end{tabular}
    }
  }
  \hspace{-10mm}\subfigure[][\Gls{interferingthread}]{
    \texttt{
      \begin{tabular}{ll}
        \\
        \\
        7 & ptr = complex\_local\_condition();\\
        8 & *ptr = NULL;\\
        \\
        \\
      \end{tabular}
    }
  }
  \caption{An example bug}
  \label{fig:fix_bug:complex_local}
\end{sanefig}

\noindent
The first step in producing such a fix is to infer critical sections
of the dynamic \glspl{cfg} such that running those sections atomically
with respect to each other would be sufficient to eliminate the bug.
These will not necessarily cover the entirety of the dynamic
\glspl{cfg}.  Consider, for instance, the bug in
\autoref{fig:fix_bug:complex_local}.  In this example, the
\gls{crashingthread} will crash if statement \texttt{8} intercedes
between statements \texttt{2} and \texttt{4}, and so a reasonable
strategy for fixing this bug would be to make statements \texttt{2},
\texttt{3}, and \texttt{4} execute atomically with respect to
statement \texttt{8}.  The dynamic \glspl{cfg} will include those
statements, but are also likely to include at least a suffix of
\texttt{complex\_local\_condition()}, if not the entire function, and
so rendering both \glspl{cfg} atomic in their entirety would be
unnecessarily conservative.  The resulting fix would suffer higher
than necessary loss of concurrency and hence potentially higher than
necessary loss of performance.

The \gls{verificationcondition} can be used to derive critical
sections which are smaller, and so eliminate less desirable
concurrency, but which still correctly disallow the undesirable sort.
As discussed in \autoref{sect:derive}, the
\gls{verificationcondition}'s happens-before tests
$\happensBeforeEdge$ completely specify the happens-before ordering
which is necessary for the bug to reproduce; any instruction
\emph{not} mentioned in such a test can be ordered arbitrarily without
influencing the bug's reproducibility and so should be excluded from
the critical sections.  In the example, the
\gls{verificationcondition} will include tests of $\happensBefore{\tt
  2}{\tt 8}$ and $\happensBefore{\tt 8}{\tt 4}$, plus some
$\happensBeforeEdge$-free \gls{side condition}, and so the critical
sections need only include statements \texttt{2}, \texttt{4}, and
\texttt{8}, plus those on paths between them (in this case, just
statement \texttt{3}).  \texttt{complex\_local\_condition()} is
excluded, as desired.

\begin{sanefig}
  \centerline{
    \texttt{
      \begin{tabular}{ll}
        7  & ptr = complex\_local\_calculation();\\
        8a & *ptr = NULL;\\
        8b & *ptr = NULL;\\
      \end{tabular}
    }
  }
  \caption{A slightly extended version of
    \autoref{fig:fix_bug:complex_local}'s
    \texttt{interfering\_thread}.}
  \label{fig:fix_bug:complex_local2}
\end{sanefig}

Note that this is not guaranteed to produce an optimally small
selection of critical sections.  Consider, for example, a program with
the same crashing thread as the previous example but an interfering
thread in which the pointer is assigned to twice, as shown in
\autoref{fig:fix_bug:complex_local2}.  The fix generating process must
now decide whether to release the lock between \texttt{8a} and
\texttt{8b}, or, equivalently, whether to use two critical sections,
each covering a single instruction, or a single section which covers
both.  Either approach will correctly eliminate the bug, but with
different performance characteristics: dropping and reacquiring the
lock reduces the duration of the critical sections, and so will
improve the program's liveness properties, but increases the number of
lock operations, and so will degrade the program's single-threaded
performance.  It is impossible to determine which is better without a
detailed description of the program's desired behaviour, which
{\technique} lacks, and so {\technique} instead relies on a simple
heuristic: if the operations are within \gls{alpha} instructions then
it uses a single critical section, holding the lock throughout;
otherwise it uses two, releasing the lock between them.  This rule was
chosen largely for ease of implementation, as it matches that used for
clustering instructions when building the \glspl{cfg}, but the results
produced appear to broadly reasonable in most circumstances.

\section{Structure of fixes}

\noindent
Once {\technique} has identified the fragments of \gls{dynamic cfg}
which are to be made atomic, it must build a fix which does so.  These
fixes consist of two parts: the \gls{shadowfragment}, a fragment of
machine code which emulates the relevant part of the original program
with the addition of appropriate lock acquire and release operations;
and the patch strategy, a set of modifications to the original program
which ensure that the shadow gains control of the program when
necessary.  The patch strategy has already been discussed in
\autoref{sect:enforce:gain_control}.  The \gls{shadowfragment} is in
many respects analogous to the crash enforcement interpreter
(\autoref{sect:enforce:interpreting}): both gain and relinquish
control of program threads as they run; both are semantically
equivalent to some fragment of the original program; and both are
responsible for introducing additional synchronisation to the
program's execution.  The differences lie in the type of
synchronisation added (the enforcement interpreter uses message
operations to encourage program threads to interleave their
operations, whereas the \gls{shadowfragment} uses locks to prevent
them from doing so) and in the way they emulate the program (the
enforcement interpreter interprets the program's instructions, whereas
the \gls{shadowfragment} incorporates them directly into its own
machine code).  These differences lead to significantly different
algorithms.

\begin{sanefig}
  {\hfill}
  \subfigure[][\Gls{static cfg}]{
    \begin{tikzpicture}
      \node (root) {};
      \node (A) [below = of root, CfgInstr] {A};
      \node (B) [below = of A, CfgInstr] {B};
      \node (C) [below = of B, CfgInstr] {C};
      \node (D) [below = of C, CfgInstr] {D};
      \node [left = .5 of B] {};
      \node [right = .5 of B] {};
      \node [below = .35 of D] {\phantom{$\bot$}};
      \draw[->] (root) -- (A);
      \draw[->] (A) -- (B);
      \draw[->] (B) -- (C);
      \draw[->,ifTrue] (C) -- (D);
      \draw[->,ifFalse] (C.west) ..controls +(-.3,0) and +(0,-0.3) .. ++(-.5,.5)
           -- ++(0,2.228)
           ..controls +(0,0.3) and +(-.3,0) .. ++(.49,.5)
           -- (A.west);
    \end{tikzpicture}
    \label{fig:fix:eg:static}
  }
  {\hfill}
  \subfigure[][\Gls{dynamic cfg}]{
    \begin{tikzpicture}
      \node (root) {};
      \node (B0) [below = of root, CfgInstr] {$B_0$};
      \node (C0) [below = of B0, CfgInstr] {$C_0$};
      \node (A0) [below = of C0, CfgInstr] {$A_0$};
      \node (B1) [below = of A0, CfgInstr] {$B_1$};
      \node (bot) [below = of B1] {$\bot$};
      \node [left = of B0] {};
      \draw[->] (root) -- (B0);
      \draw[->] (B0) -- (C0);
      \draw[->,ifTrue]
          (C0.east) ..controls +(.3,0) and +(0,.3).. ++ (.5,-.5)
          -- ++(0,-3.89)
          ..controls +(0,-.3) and +(.3,0).. ++(-.49,-.5)
          -- (bot.east);
      \draw[->,ifFalse] (C0) -- (A0);
      \draw[->] (A0) -- (B1);
      \draw[->] (B1) -- (bot);
    \end{tikzpicture}
    \label{fig:fix:eg:dynamic}
  }
  {\hfill}
  \subfigure[][Patch strategy]{
    \raisebox{38mm}{
      $\left\{
      \begin{tabular}{rl}
        $\mathit{Patch}$: & $\{\textrm{A}\}$\\
        $\mathit{Cont}$:  & $\{\textrm{A}, \textrm{B}\}$\\
      \end{tabular}
      \right\}$
    }
    \label{fig:fix:eg:strategy}
  }
  {\hfill}
  \subfigure[][\protect\Gls{shadowfragment}]{
    \begin{tikzpicture}[outer sep=-2pt, node distance = 1cm and .5cm]
      \node (A0) [CfgInstr] {A};
      \node (Acq) [below = of A0, CfgInstr] {Acquire lock};
      \node (B0) [below = of Acq, CfgInstr] {B};
      \node (C) [below = of B0, CfgInstr, outer sep = -3pt] {C};
      \node (A1) [below left = of C, CfgInstr] {A};
      \node (B1) [below = of A1, CfgInstr] {B};
      \node (Rel) [below right = 1 and -.5 of C, CfgInstr] {Release lock};
      \node (D) [below = of Rel] {\texttt{jmp} D};
      \draw[->] (A0) -- (Acq);
      \draw[->] (Acq) -- (B0);
      \draw[->] (B0) -- (C);
      \draw[->,ifFalse] (C.south west) -- (A1);
      \draw[->,ifTrue] (C.south east) -- (Rel.north);
      \draw[->] (A1) -- (B1);
      \draw[->] (B1.west) ..controls +(-.3,0) and +(0,-.3) .. ++(-.5,.5)
        -- ++(0,1.88)
        .. controls +(+0,.3) and +(-.3,0) .. ++(.5,.5)
        -- (C.west);
      \draw[->] (Rel) -- (D);
    \end{tikzpicture}
    \label{fig:fix:eg:shadow}
  }
  {\hfill}
  \caption{Example of the \protect\gls{shadowfragment} algorithm; see
    text for full explanation.}
  \label{fig:fix:eg}
\end{sanefig}

\autoref{fig:fix:eg} shows an example \gls{shadowfragment} generated
for one of the critical sections involved in a simple bug.  The
\gls{dynamic cfg} indicates that the critical section must run from
the start of instruction B in one iteration of the loop to the end of
instruction B in the next iteration.  Ideally, the
\gls{shadowfragment} would therefore gain control at instruction B,
but the patch strategy was in this case unable to do so and instead
gained control at A.  The resulting \gls{shadowfragment} starts by
emulating A, compensating for the patch strategy's deficiency, before
acquiring the lock.  It then proceeds to emulate the original program
loop under the lock, until the branch at C indicates that the loop
should finish.  At that point, the \gls{shadowfragment} releases the
lock and returns the program to its normal operation by branching to
the original instruction B.

The \glspl{cfg} involved in building a fix can usefully be read as a
kind of regular automata.  The static and shadow \glspl{cfg}
effectively generate streams of instructions, while
\begin{wrapfigure}{o}{4.4cm}
  \vspace{-12pt}
  \begin{figgure}
    \centerline{
  \begin{tikzpicture}[node distance = 0.5]
    \node (A) {*} edge [in=150,out=210,loop] ();
    \node [right = 0.5 of A] (E) {\texttt{jmp}};
    \node [below = of A] (B) {\shortstack{Acquire\\lock}};
    \node [below = of B] (C) {*} edge [in=150,out=210,loop] ();
    \node [below = of C] (D) {\shortstack{Release\\lock}};
    \node [left = .8 of A] {\shortstack[r]{Lock\\unheld}};
    \node [left = .8 of C] {\shortstack[r]{Lock\\held}};
    \draw[->] (A) -- (B);
    \draw[->] (B) -- (C);
    \draw[->] (C) -- (D);
    \draw[->] (A) -- (E);
    \draw[->] (D.south)
      ..controls +(0,-.1) and +(.1,0) .. ++(-.2,-.2)
      -- ++(-.6,0)
      ..controls +(-.1,0) and +(0,-.1) .. ++(-.2,.2)
      -- ++(0,4.9)
      ..controls +(0,.1) and +(-.1,0) .. ++(.2,.2)
      -- ++(.6,0)
      ..controls +(.1,0) and +(0,.1) .. ++(.2,-.2)
      -- (A.north);
    \draw[->] (A.north) ++(0,.5) -- (A.north);
  \end{tikzpicture}
  }
  \caption{Lock discipline automaton.  The \texttt{jmp} state matches
    transfers of control back to the original program and the * states
    any ordinary instruction.}
  \label{fig:fix:lock_discipline}
  \end{figgure}
  \vspace{-12pt}
\end{wrapfigure}
the dynamic one
recognises fragments of those streams.  This provides a convenient way
of describing the correctness requirements for the
\gls{shadowfragment}:
\begin{enumerate}
\item It must correctly emulate the \gls{static cfg}, in the sense of
  generating the same sequences of instructions (ignoring lock acquire
  and release operations), starting from any instruction in the patch
  strategy's $\mathit{Patch}$ set.
\item It must correctly enforce the desired synchronisation, in the
  sense that any subsequences which match the \gls{dynamic cfg} must
  hold the lock for their entire duration.
\item It must follow correct lock discipline, in the sense that any
  instruction sequences generated must match the automaton in
  \autoref{fig:fix:lock_discipline}.
\end{enumerate}
The example in \autoref{fig:fix:eg} follows all three rules; the next
section explains how to generate \glspl{shadowfragment} which do so in
the general case.

\section{Generating the \protect\gls{shadowfragment}}

\begin{sanefig}
  \newcommand{\lookaside}[1]{\multicolumn{5}{c}{\leavevmode\leaders\hbox{\vrule height .55ex depth -.45ex width 2pt \hspace{2pt}}\hfill\hspace{-3pt}\textit{#1\!}
      {\leavevmode\xleaders\hbox{\vrule height .55ex depth -.45ex width 2pt \hspace{2pt}}\hfill \hspace{-2pt}}
    } \vspace{-4pt}\\}
  \newcommand{\sectsep}[2]{\multicolumn{5}{c}{\leavevmode\cleaders\vrule height .55ex depth -.45ex\hfill ~#1
      {\leavevmode\leaders\vrule height .5ex depth -.45ex\hfill}
    } \vspace{#2}\\}
  \newcommand{\twolineNT}[2]{%
    \raisebox{1.35ex}{%
      \graphNT{%
        \raisebox{-2.7ex}{%
          \shortstack[c]{%
            #1\\
            #2
          }}}}}
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{ccc p{3.16cm} c}
    \sectsep{\textbf{CheckForEntry} to \textbf{Lock}}{-4pt}
    \twolineNT{$\mathrm{X}, \alpha, l$}{\textbf{CheckForEntry}} & $\Rightarrow$ & \twolineNT{$\mathrm{X}, \alpha \cup \mathit{startingAt}(X),$}{$l, \textbf{Lock}$} & & \production{1}\\

    \sectsep{\textbf{Lock} to \textbf{Return}}{-4pt}
    \graphNT{$\mathrm{X}, \alpha, \mathit{unheld}, \textbf{Lock}$} & $\Rightarrow$ & \begin{tikzpicture}[baseline = (current bounding box.center)]
      \node (r) {Acquire lock};
      \node (s) [style=graphNT, below = .3 of r] {$\mathrm{X}, \alpha, \mathit{held}, \textbf{Return}$};
      \draw[->] (r) -- (s);
    \end{tikzpicture} & $\alpha \not= \varnothing$ & \production{2_a}\\
    \graphNT{$\mathrm{X}, \alpha, l, \textbf{Lock}$} & $\Rightarrow$ & \graphNT{$\mathrm{X}, \alpha, l, \textbf{Return}$} & If $\neg$\production{2_a} & \production{2_b}\\

    \sectsep{\textbf{Return} to \textbf{Emul}}{-4pt}
    \twolineNT{$\mathrm{X}, \varnothing, \mathit{unheld},$}{\textbf{Return}} & $\Rightarrow$ & \texttt{jmp} X & $\mathrm{x} \not\in \mathit{Cont}$ & \production{3_a} \\
    \graphNT{$\mathrm{X}, \alpha, l, \textbf{Return}$} & $\Rightarrow$ & \graphNT{$\mathrm{X}, \alpha, l, \textbf{Emul}$} & If $\neg$\production{3_a} & \production{3_b} \\

    \sectsep{\textbf{Emul} to \textbf{Unlock}}{-8pt}
    \lookaside{Indirect control flow instructions described in text}
    \raisebox{2.5mm}{\graphNT{\raisebox{-2.5mm}{$\begin{tikzpicture}[baseline = (current bounding box.center)]
        \node (r) {\texttt{jcc}};
        \node (s) at (-.3,-.7) {X};
        \node (t) at ( .3,-.7) {Y};
        \draw[->,ifTrue] (r) -- (s);
        \draw[->,ifFalse] (r) -- (t);
      \end{tikzpicture}, \alpha, l, \textbf{Emul}$}}} & $\Rightarrow$ & 
      \begin{tikzpicture}[baseline = (current bounding box.center)]
        \node (r) at (.8,0) {\texttt{jcc}};
        \node (s) at (-.7,-1.1) {\twolineNT{$\mathrm{X}, \mathit{adv}(\mathrm{X}, \alpha),$}{$l, \textbf{Unlock}$}};
        \node (t) at ( 2.3,-1.1) {\twolineNT{$\mathrm{Y}, \mathit{adv}(\mathrm{Y}, \alpha),$}{$l, \textbf{Unlock}$}};
        \draw[->,ifTrue] (r) -- (s);
        \draw[->,ifFalse] (r) -- (t);
      \end{tikzpicture}
      \renewcommand{\arraystretch}{1.5}
    & & \production{4_a}\\
    \graphNT{\texttt{jmp} X, $\alpha$, $l$, \textbf{Emul}} & $\Rightarrow$ & \twolineNT{$\mathrm{X}, \mathit{adv}(\mathrm{X}, \alpha),$}{$l, \textbf{Unlock}$} & & \production{4_b} \\
    \raisebox{2.5mm}{\graphNT{\raisebox{-2.5mm}{$\begin{tikzpicture}[baseline = (current bounding box.center)]
          \node (r) {\texttt{call} X};
          \node (s) [below = .3 of r] {Y};
          \draw[->] (r) -- (s);
      \end{tikzpicture}, \alpha, l, \textbf{Emul}$}}} & $\Rightarrow$ &
    \begin{tikzpicture}[baseline = (current bounding box.center)]
      \node (r) {\texttt{push} y's address};
      \node (s) [below = .3 of r] {\twolineNT{$\mathrm{X}, \mathit{adv}(\mathrm{X},\alpha),$}{$l, \textbf{Unlock}$}};
      \draw[->] (r) -- (s);
    \end{tikzpicture} & \RaggedRight X not a library function & \production{4_c} \\
    \raisebox{2.5mm}{\graphNT{\raisebox{-2.5mm}{$\begin{tikzpicture}[baseline = (current bounding box.center)]
          \node [minimum height=3ex, outer sep = -2pt] (r) {x};
          \node (s) [below = .3 of r] {Y};
          \draw[->] (r) -- (s);
      \end{tikzpicture}, \alpha, l, \textbf{Emul}$}}} & $\Rightarrow$ &
    \begin{tikzpicture}[baseline = (current bounding box.center)]
      \node (r) {x};
      \node (s) [below = .3 of r] {\twolineNT{$\mathrm{Y}, \mathit{adv}(\mathrm{Y},\alpha),$}{$l, \textbf{Unlock}$}};
      \draw[->] (r) -- (s);
    \end{tikzpicture} & \RaggedRight x some other instruction type & \production{4_d} \\

    \sectsep{\textbf{Unlock} to \textbf{CheckForEntry}}{-4pt}
    \twolineNT{$\mathrm{X}, \varnothing, \mathit{held},$}{\textbf{Unlock}} & $\Rightarrow$ & \begin{tikzpicture}[baseline = (current bounding box.center)]
      \node (r) {Release lock};
      \node (s) [below = .3 of r] {\twolineNT{$\mathrm{X}, \varnothing, \mathit{unheld},$}{\textbf{CheckForEntry}}};
      \draw[->] (r) -- (s);
    \end{tikzpicture} & & \production{5_a}\\
    \graphNT{$\mathrm{X}, \alpha, l, \textbf{Unlock}$} & $\Rightarrow$ & \twolineNT{$\mathrm{X}, \alpha, l,$}{\textbf{CheckForEntry}} & If $\neg$\production{5_a} & \production{5_b}\\
  \end{tabular}

  \caption{The patch generating algorithm as a graph grammar.  The
    terminals of this grammar are instructions in a newly-generated
    \gls{static cfg} representing the \gls{shadowfragment}.
    The ``If $\neg$\protect\production{2_a}'' annotation indicates
    that the production is used only if \protect\production{2_a} does
    not match.  \textrm{X} and \textrm{Y} match fragments of the
    \gls{static cfg}, \textrm{x} matches an individual static
    instructions, $\alpha$ matches a (possibly empty) set of
    \gls{dynamic cfg} nodes, and $l$ matches either $\mathit{held}$ or
    $\mathit{unheld}$.  $\mathit{startingAt}$ and $\mathit{adv}$ are
    defined in the text.}
  \label{fig:fix:graph_grammar}
\end{sanefig}

\begin{sanefig}
  \hfill
  \begin{tikzpicture}
    \node (typename) {\textsc{Configuration}\!};
    \node (eqsign) [right = 0 of typename] {\raisebox{-2.5mm}{=}\hspace{.8mm}~};
    \node [graphNT, right = 0 of eqsign] {
      \begin{tabular}{rl}
        $\mathit{static}$: & \textsc{StaticCfgNode},\\
        $\mathit{dynamic}$: & \textsc{Set}(\textsc{DynamicCfgNode}),\\
        $\mathit{lock}$:  & $\left\{\mathit{held}, \mathit{unheld}\right\}$,\\
        $\mathit{phase}$: & $\left\{\raisebox{-1.25ex}{\shortstack[l]{
            $\mathbf{CheckForEntry}, \mathbf{Lock},$\\
            $\mathbf{Emul}, \mathbf{Unlock}$}}\right\}$\\
      \end{tabular}
    };
  \end{tikzpicture}
  \hfill{}
  \caption{The \textsc{Configuration} type, used as the non-terminal
    type in the shadow generating algorithm in
    \autoref{fig:fix:graph_grammar}.}
  \label{fig:fix:configuration}
\end{sanefig}

\begin{sanefig}
  {\hfill}
  \begin{tikzpicture}
    \node (a) {\raisebox{0.5mm}{$\mathit{initial}$}\!};
    \node (eqsign) [right = 0 of a] {\raisebox{-2.5mm}{=}\!};
    \node [right = 0 of eqsign] {
      $\left\{
      \graphNT{
        \begin{tabular}{r@{=}l}
          $\mathit{static}$ & $p$ \\
          $\mathit{dynamic}$ & $\varnothing$ \\
          $\mathit{lock}$ & $\mathit{unheld}$ \\
          $\mathit{phase}$ & $\mathbf{CheckForEntry}$ \\
        \end{tabular}
      }\,
      \middle|\,p \in Patch\right\}$};
  \end{tikzpicture}
  {\hfill}
  \caption{The initial set of non-terminals for the graph grammar in
    \autoref{fig:fix:graph_grammar}.  There is one initial
    non-terminal for every entry in the $\mathit{Patch}$ set.}
  \label{fig:fix:initial_configuration}
\end{sanefig}

\noindent
The \gls{shadowfragment} is produced by a graph generating grammar,
given in \autoref{fig:fix:graph_grammar}, over the non-terminal
\textsc{Configuration} type, given in \autoref{fig:fix:configuration},
starting from the non-terminal set $\mathit{initial}$, given in
\autoref{fig:fix:initial_configuration}.  The \textsc{Configuration}
type is used to represent the program's positions in the various
regular automata:
\begin{itemize}
\item $\mathit{static}$ gives the position in the program's
  \gls{static cfg}.
\item $\mathit{dynamic}$ gives the set of possible positions in the
  \gls{dynamic cfg}.
\item $\mathit{lock}$ gives the position in the lock discipline
  automaton (either $\mathit{held}$ for the lock held state or
  $\mathit{unheld}$ for the lock unheld one).
\item $\mathit{phase}$ records the program's progress through the
  various phases within a particular instruction.
\end{itemize}
The grammar makes use of two utility functions:
\begin{itemize}
\item $\mathit{startingAt}(r)$ maps from a \gls{static cfg} node $r$
  to the set of \gls{dynamic cfg} nodes which match $r$ and which
  start a new \gls{dynamic cfg} fragment.  In the example of
  \autoref{fig:fix:eg}, $\mathit{startingAt}$ maps B to $\{B_0\}$ and
  every other instruction to $\varnothing$.
\item $\mathit{adv}(\mathrm{x}, \alpha)$, where $\mathrm{x}$ is a
  \gls{static cfg} node and $\alpha$ a set of dynamic ones, is defined
  by
  \begin{displaymath}
    \mathit{adv}(\mathrm{x}, \alpha) = \left\{r \middle| s \in \alpha \wedge r \in s.\mathit{next} \wedge r.\mathit{static} = \mathrm{x}\right\}
  \end{displaymath}
  $n.\mathit{next}$ is the set of \gls{dynamic cfg} nodes which can
  follow the $n$ and $n.\mathit{static}$ is the \gls{static cfg} node
  corresponding to $n$.
\end{itemize}

\noindent
\autoref{fig:fix:eg:application} shows how to apply this grammar to
the example.  Note that this figure shows both the output
\gls{shadowfragment} (using unboxed nodes and single arrows) and the
way in which it is generated (using boxed nodes and double arrows).
The initial non-terminal \graphNT{A, $\varnothing$, $\mathit{unheld}$,
  \textbf{CheckForEntry}}, at the top-left of the figure, is
transformed by \production{1} to the non-terminal \graphNT{A,
  $\varnothing$, $\mathit{unheld}$, \textbf{Lock}}, which is in turn
transformed by productions \production{2_b} and \production{3_b} into
the non-terminal \graphNT{A, $\varnothing$, $\mathit{unheld}$,
  \textbf{Emul}}.  Production \production{4_d} then transforms this
into the terminal instruction A followed by a further non-terminal
\graphNT{B, $\varnothing$, $\mathit{unheld}$, \textbf{Unlock}}.  This
new non-terminal is itself transformed by production \production{5_b}
and the process continues until all non-terminals have been
transformed.  The resulting graph forms the \gls{shadowfragment}, as
shown in \autoref{fig:fix:eg:shadow}.

\begin{sanefig}
  \newcommand{\graphLine}[3]{\draw [->,double] (#1) -- node [above = -.05] {\production{#2}} (#3);}
  \newcommand{\nextline}[3]{\draw [->,double] (#1.east) -- ++(.2,0) -- ++(0,-.5) -- node [above = -.05] {\production{#2}} ++(-14.5,0) |- (#3.west);}
  \begin{tikzpicture}
    \tikzstyle{graphNT}+=[minimum width=2.2cm];
    \node at (0,0) (CFE) {\textbf{CheckForEntry}};
    \node at (3,0) (Lock) {\textbf{Lock}};
    \node at (6,0) (Return) {\textbf{Return}};
    \node at (9,0) (Emul) {\textbf{Emul}};
    \node at (11.8,0) (Unlock) {\textbf{Unlock}};

    \node at (0,-1) (r0) {};
    \node at (0,-2.3) (r1) {};

    \node at (0,-3.6) (r2) {};
    \node at (0,-4.95) (r3) {};
    \node at (0,-6.25) (r4) {};

    \node at (0,-7.55) (r5) {};

    \path (r5) ++(0,-2.86) node (r9) {}
               ++(0,-1) node (r10) {}
               ++(0,-1.95) node (r11) {}
               ++(0,-1) node (r12) {}
               ++(0,-1.3) node (r13) {};

    \node at (CFE |- r0) (AnfCFE) [graphNT] {A,$\varnothing$,$\mathit{unheld}$};
    \node at (Lock |- r0) (AnfL) [graphNT] {A,$\varnothing$,$\mathit{unheld}$};
    \node at (Return |- r0) (AnfR) [graphNT] {A,$\varnothing$,$\mathit{unheld}$};
    \node at (Emul |- r0) (AnfE) [graphNT] {A,$\varnothing$,$\mathit{unheld}$};
    \node at (Unlock |- r0) (A0) [CfgInstr] {A};
    \node at (Unlock |- r1) (BnfU) [graphNT] {B,$\varnothing$,$\mathit{unheld}$};
    \graphLine{AnfCFE}{1}{AnfL}
    \graphLine{AnfL}{2_b}{AnfR}
    \graphLine{AnfR}{3_b}{AnfE}
    \graphLine{AnfE}{4_d}{A0}
    \draw[->] (A0) -- (BnfU);

    \node at (CFE |- r2) (BnfCFE) [graphNT] {B,$\varnothing$,$\mathit{unheld}$};
    \node at (Lock |- r2) (B0fL) [graphNT] {B,$B_0$,$\mathit{unheld}$};
    \node at (Return |- r2) (Acq) [CfgInstr, inner sep = 0, outer sep=-1pt] {Acquire lock};
    \node at (Return |- r3) (B0tR) [graphNT] {B,$B_0$,$\mathit{held}$};
    \node at (Emul |- r3) (B0tE) [graphNT] {B,$B_0$,$\mathit{held}$};
    \node at (Unlock |- r3) (B0) [CfgInstr] {B};
    \node at (Unlock |- r4) (C0tU) [graphNT] {C,$C_0$,$\mathit{held}$};
    \graphLine{BnfCFE}{1}{B0fL}
    \graphLine{B0fL}{2_a}{Acq}
    \draw[->] (Acq) -- (B0tR);
    \graphLine{B0tR}{3_b}{B0tE}
    \graphLine{B0tE}{4_d}{B0}
    \draw[->] (B0) -- (C0tU);

    \nextline{BnfU}{5_b}{BnfCFE};

    \node at (CFE |- r5) (C0tCFE) [graphNT] {C,$C_0$,$\mathit{held}$};
    \node at (Lock |- r5) (C0tL) [graphNT] {C,$C_0$,$\mathit{held}$};
    \node at (Return |- r5) (C0tR) [graphNT] {C,$C_0$,$\mathit{held}$};
    \node at (Emul |- r5) (C0tE) [graphNT] {C,$C_0$,$\mathit{held}$};
    \node at (Unlock |- r5) (C0) [CfgInstr] {C};
    \path (C0.south) ++ (-.6,-1.4) node (DntU) [graphNT, minimum width = 0] {\shortstack[c]{D,$\varnothing$,\\$\mathit{held}$}};
    \path (C0.south) ++ (.6,-.8) node (A0tU) [graphNT, minimum width = 0] {\shortstack[c]{A,$A_0$,\\$\mathit{held}$}};
    \graphLine{C0tCFE}{1}{C0tL}
    \graphLine{C0tL}{2_b}{C0tR}
    \graphLine{C0tR}{3_b}{C0tE}
    \graphLine{C0tE}{4_a}{C0}
    \draw[->,ifTrue] (C0.south) -- (DntU);
    \draw[->,ifFalse] (C0.south) -- (A0tU);
    \nextline{C0tU}{5_b}{C0tCFE};

    \node at (CFE |- r9) (Rel) [CfgInstr, outer sep = -1pt] {\!Release lock\!};
    \node at (CFE |- r10) (D0fCFE) [graphNT] {D,$\varnothing$,$\mathit{unheld}$};
    \node at (Lock |- r10) (D0fL) [graphNT] {D,$\varnothing$,$\mathit{unheld}$};
    \node at (Return |- r10) (D0fR) [graphNT] {D,$\varnothing$,$\mathit{unheld}$};
    \node at (Emul |- r10) (D) [CfgInstr] {~~~\texttt{jmp} D~~~};
    \draw[->] (Rel) -- (D0fCFE);
    \graphLine{D0fCFE}{1}{D0fL}
    \graphLine{D0fL}{2_b}{D0fR}
    \graphLine{D0fR}{3_a}{D}
    \draw [->,double] (DntU.east) -- ++(.2,0) -- ++(0,-.65) -- node [pos=.455, above = -.05] {\production{5_a}} ++(-13.31,0) --  ++(0,-.5) -- (Rel.west);

    \node at (CFE |- r11) (A0tCFE) [graphNT] {A,$A_0$,$\mathit{held}$};
    \node at (Lock |- r11) (A0tL) [graphNT] {A,$A_0$,$\mathit{held}$};
    \node at (Return |- r11) (A0tR) [graphNT] {A,$A_0$,$\mathit{held}$};
    \node at (Emul |- r11) (A0tE) [graphNT] {A,$A_0$,$\mathit{held}$};
    \node at (Unlock |- r11) (A1) [CfgInstr] {A};
    \node at (Unlock |- r12) (B1tU) [graphNT] {B,$B_1$,$\mathit{held}$};
    \graphLine{A0tCFE}{\one}{A0tL}
    \graphLine{A0tL}{2_b}{A0tR}
    \graphLine{A0tR}{3_b}{A0tE}
    \graphLine{A0tE}{4_d}{A1}
    \draw[->] (A1) -- (B1tU);
    \draw [->,double] (A0tU.east) -- ++(.2,0) -- ++(0,-3.9) -- node [pos=.505, above = -.05] {\production{5_b}} ++(-14.58,0) |- (A0tCFE.west);

    \node at (CFE |- r13) (B1tCFE) [graphNT] {\shortstack[c]{B,$B_1$,\\$\mathit{held}$}};
    \node at (Lock |- r13) (B01tL) [graphNT] {\shortstack[c]{B,$\{B_0;B_1\}$,\\$\mathit{held}$}};
    \node at (Return |- r13) (B01tR) [graphNT] {\shortstack[c]{B,$\{B_0;B_1\}$,\\$\mathit{held}$}};
    \node at (Emul |- r13) (B01tE) [graphNT] {\shortstack[c]{B,$\{B_0;B_1\}$,\\$\mathit{held}$}};
    \node at (Unlock |- r13) (B1) [CfgInstr] {B};
    \graphLine{B1tCFE}{1}{B01tL}
    \graphLine{B01tL}{2_a}{B01tR}
    \graphLine{B01tR}{3_b}{B01tE}
    \graphLine{B01tE}{4_d}{B1}
    \draw[->] (B1.east) -- ++(1.4,0) -- ++(0,10.0) -| (C0tU.north);
    \nextline{B1tU}{5_b}{B1tCFE}

  \end{tikzpicture}
  \caption{Application of the algorithm in
    \autoref{fig:fix:graph_grammar} to the example in
    \autoref{fig:fix:eg}.  In this figure, boxed nodes show
    \textsc{Configuration}s and double arrows show the productions
    used to transform between them, while unboxed nodes and single
    arrows show the terminals and output edges.  The final
    \protect\gls{shadowfragment}, \autoref{fig:fix:eg:shadow}, can be
    recovered from this figure by removing all of the boxed nodes and
    double arrows.  The $\mathit{phase}$ field of non-terminals is
    shown in the headings above the graph, rather than in the
    non-terminals themselves.}
  \label{fig:fix:eg:application}
\end{sanefig}

\begin{sanefig}
  \begin{tikzpicture}
    \node (A0) [CfgInstr] {A};
    \node (B0) [CfgInstr, right = of A0] {B};
    \node (C0) [CfgInstr, right = of B0] {C};
    \node (A1) [CfgInstr, right = of C0] {A};
    \node (B1) [CfgInstr, right = of A1] {B};
    \node (C1) [CfgInstr, right = of B1] {C};
    \node (A2) [CfgInstr, right = of C1] {A};
    \node (B2) [CfgInstr, right = of A2] {B};
    \node (C2) [CfgInstr, right = of B2] {C};
    \node (D)  [CfgInstr, right = of C2] {D};
    \draw[->] (A0) -- (B0);
    \draw[->] (B0) -- (C0);
    \draw[->,ifFalse] (C0) -- (A1);
    \draw[->] (A1) -- (B1);
    \draw[->] (B1) -- (C1);
    \draw[->,ifFalse] (C1) -- (A2);
    \draw[->] (A2) -- (B2);
    \draw[->] (B2) -- (C2);
    \draw[->,ifTrue] (C2) -- (D);

    \node (b01) [CfgInstr, below = .3 of B0] {$B_0$};
    \node (c01) [CfgInstr] at (C0 |- b01) {$C_0$};
    \node (a11) [CfgInstr] at (A1 |- b01) {$A_0$};
    \node (b11) [CfgInstr] at (B1 |- b01) {$B_1$};
    \draw[->] (b01) -- (c01);
    \draw[->,ifFalse] (c01) -- (a11);
    \draw[->] (a11) -- (b11);
    \draw (b01.south west) -- ++(0,-.2) -| node [pos=0.25, below] {First critical section} (b11.south east);

    \node (dummy2) [below = .9 of b01] {};
    \node (b12) [CfgInstr] at (B1 |- dummy2) {$B_0$};
    \node (c12) [CfgInstr] at (C1 |- dummy2) {$C_0$};
    \node (a22) [CfgInstr] at (A2 |- dummy2) {$A_0$};
    \node (b22) [CfgInstr] at (B2 |- dummy2) {$B_1$};
    \draw[->] (b12) -- (c12);
    \draw[->,ifFalse] (c12) -- (a22);
    \draw[->] (a22) -- (b22);
    \draw (b12.south west) -- ++(0,-.2) -| node [pos=0.25, below] {Second critical section} (b22.south east);

    \draw[color=black!20] (B0) -- (b01);
    \draw[color=black!20] (C0) -- (c01);
    \draw[color=black!20] (A1) -- (a11);
    \draw[color=black!20] (B1) -- (b11) -- (b12);

    \draw[color=black!20] (C1) -- (c12);
    \draw[color=black!20] (A2) -- (a22);
    \draw[color=black!20] (B2) -- (b22);
  \end{tikzpicture}
  {\hfill}
  \caption{The effect of running the loop in
    \autoref{fig:fix:eg:static} three times.  Because static
    instruction {\rm B} could be either $B_0$ or $B_1$ the
    \gls{dynamic cfg} in \autoref{fig:fix:eg:dynamic} matches this
    sequence in two, overlapping, places, resulting in two,
    overlapping, critical sections.  The enforcer is unable to release
    the lock between loop iterations and must hold it for the loop's
    entire duration.}
  \label{fig:fix:loop3}
\end{sanefig}
\section{Deadlocks}
\label{sect:fix:deadlocks}
Note that in this example the entire loop, except for the first A
instruction, is run under the lock.  The lock could therefore be held
for an arbitrarily large number of instructions, even though the
desired critical section contained only four.  The fundamental problem
here is the ambiguous mapping between the static and dynamic
\glspl{cfg}, and in particular the fact that the static B instruction
occurs twice in the \gls{dynamic cfg} as $B_0$ and $B_1$.  The
enforcer cannot tell, when it observes the program running instruction
B, whether it should treat that instruction as $B_0$, which starts a
critical section, or $B_1$, which ends one, and conservatively treats
it as both.  The critical section started by $B_0$ overlaps that ended
by $B_1$ and there is no opportunity to release the lock during the
body of the loop.  \autoref{fig:fix:loop3} illustrates this behaviour
graphically.

This implies that {\technique} could potentially hold its lock for a
very long time, and hence that lock acquisition could impose long
delays on the program.  In extreme cases, it could even deadlock.
{\Technique} mitigates this problem using a timeout in the lock
acquire operation.  If this timeout expires then the
\gls{shadowfragment} returns the program to normal operation,
abandoning its attempt to impose the desired
synchronisation.\kern-1.25pt\fnote{At the level of the graph grammar,
  this means that production \production{2_a} is extended to branch to
  \graphNT{X, $\varnothing$, $\mathit{unheld}$, \textbf{Return}} when
  lock acquisition fails.}  This risks re-introducing the original
bug, but ensures that {\technique} will never introduce any new
deadlocks.

\section{Control flow}
Most instructions in the input \gls{cfg} will be copied verbatim to
the \gls{shadowfragment}, apart from some straightforward adjustments
to addressing modes, as part of the \textbf{Emul} phase.  The
exception is control flow instructions.  Copying these directly to the
output would result in the \gls{shadowfragment} unexpectedly branching
back to the original program, completely undermining its attempts to
control the program's execution.  Such instructions therefore require
special handling.

The simplest sort of control flow operation is a direct branch.  These
transfer control to a statically-apparent target instruction, and so
can be conveniently represented in the graph structure of the
\gls{shadowfragment}.  Conditional branches in the input become
conditional branches in the output, with just the targets changed
(production \production{4_b}); unconditional branches disappear
completely (production \production{4_a}).

Direct function calls are only moderately more difficult.  Calls to
other functions within the program binary can be implemented by
pushing the return address and then branching to the called function,
reducing them to the previous case (production \production{4_c}).
Calls to library functions, by contrast, are handled by simply calling
the same library function from the \gls{shadowfragment}.  This
different behaviour reflects the way in which the initial \gls{cfg} is
built (\autoref{sect:derive:build_crashing_cfg}): {\technique} will
trace across function boundaries within a program, inlining the called
function into the caller's \gls{cfg}, but will not cross the boundary
between the program and its libraries, instead treating library
functions as simple, indivisible operations.  The \gls{shadowfragment}
algorithm matches this behaviour by inlining intra-program calls into
the fragment and leaving program to library ones as true function
calls.  Note that this implies that the \gls{shadowfragment} will
sometimes acquire program-level locks whilst holding the {\technique}
one, and that this can sometimes lead to deadlocks.  As previously
discussed, these are detected as timeouts, and cause one or more
threads to proceed unprotected.

Indirect control flow transfers, which set the instruction pointer to
a computed value, form the final class of instructions requiring
special handling.  These include computed branches, computed calls,
and the \texttt{ret} instruction.  The difficulty here is that the
target of the branch is not statically apparent, and so the branch
cannot be represented in the \gls{shadowfragment}'s static graph
structure.  The fragment must instead determine the target of the
branch at run-time, and the grammar must ensure that it generates
appropriate \gls{shadowfragment} targets for all of the original
program branch's possible targets.  There are three cases to consider:
\begin{itemize}
\item The indirect branch might select a successor instruction X such
  that $\mathit{adv}(\textrm{X}, \alpha)$ is non-empty.  In that case,
  the \gls{shadowfragment} must select the successor non-terminal
  \graphNT{X, $\mathit{adv}(\textrm{X}, \alpha)$, $l$,
    \textbf{Unlock}}.  The set of such possible successors is finite,
  statically known, and, usually, small, so the \gls{shadowfragment}
  can simply test each in turn and the grammar emit suitable
  non-terminals for each.
\item The branch might instead select an X such that
  $\mathit{adv}(\textrm{X}, \alpha)$ is empty but $\mathrm{X} \in
  \mathit{Cont}$.  There is no longer any need for the
  \gls{shadowfragment} to continue holding the lock, as
  $\mathit{dynamic}$ becomes empty, but it cannot safely return the
  program to normal operation.  The \gls{shadowfragment} must select
  the non-terminal \graphNT{X, $\varnothing$, $l$, \textbf{Unlock}},
  and the grammar must ensure that that non-terminal is
  generated.
\item Finally, the branch might select a successor which matches
  neither of the other two cases.  The \gls{shadowfragment} should
  return the program to normal operation, releasing the lock first if
  necessary.
\end{itemize}
\autoref{fig:fix:eg_indirect} shows how this works for indirect branch
instructions using an example \textsc{Configuration} and
$\mathit{Cont}$ set.  Indirect calls and \texttt{ret} instructions
behave in a broadly similar way, except that they also need to include
some updates to the stack.

\begin{sanefig}
  \shortstack[c]{
    \subfigure[][Inputs]{
      \graphNT{
        a: \texttt{jmp} $\mathit{exp}$,
        \begin{math}
          \left\{
            \begin{tikzpicture}[node distance = .2 and .3,outer sep = -2pt, inner sep = 0pt, baseline = (C.north)]
              \node (A) [CfgInstr] {$a_0$};
              \node (B) [CfgInstr, below left = of A] {$B_0$};
              \node (C) [CfgInstr, below = of A] {$C_0$};
              \node (D) [CfgInstr, below right = of A] {$D_0$};
              \draw[->] (A) -- (B);
              \draw[->] (A) -- (C);
              \draw[->] (A) -- (D);
            \end{tikzpicture},
            \begin{tikzpicture}[node distance = .2 and .3,outer sep = -2pt, inner sep = 0pt, baseline = (C.north)]
              \node (A) [CfgInstr] {$a_1$};
              \node (C) [CfgInstr, below = of A] {$C_1$};
              \draw[->] (A) -- (C);
            \end{tikzpicture},
            \begin{tikzpicture}[node distance = .2 and -.1,outer sep = -2pt, inner sep = 0pt, baseline = (C.north)]
              \node (A) [CfgInstr] {$a_2$};
              \node (C) [CfgInstr, below left = of A] {$C_1$};
              \node (D) [CfgInstr, below right = of A] {$D_1$};
              \draw[->] (A) -- (C);
              \draw[->] (A) -- (D);
            \end{tikzpicture}
          \right\}
        \end{math},
        $l$,
        \textbf{Emul}
      }
      $\mathit{Cont} = \{\mathrm{E, F}\}$
    }\\
    \hspace{\textwidth}
  }\\
  \shortstack[c]{
    \subfigure[][Output]{
      \begin{tikzpicture}[node distance = 0.3 and 1]
        \node (r) [CfgInstr] {\texttt{R0} $\leftarrow \mathit{exp}$};
        \node (b) [below = of r, CfgInstr] {\texttt{if R0 = b}};
        \node (b0) [right = of b, graphNT] {B, $B_0$, $l$, \textbf{Unlock}};
        \node (c) [below = of b, CfgInstr] {\texttt{if R0 = c}};
        \node (c0) [right = of c, graphNT] {B, $\{C_0; C_1\}$, $l$, \textbf{Unlock}};
        \node (d) [below = of c, CfgInstr] {\texttt{if R0 = d}};
        \node (d0) [right = of d, graphNT] {D, $\{D_0; D_1\}$, $l$, \textbf{Unlock}};
        \node (e) [below = of d, CfgInstr] {\texttt{if R0 = e}};
        \node (e0) [right = of e, graphNT] {E, $\varnothing$, $l$, \textbf{Unlock}};
        \node (f) [below = of e, CfgInstr] {\texttt{if R0 = f}};
        \node (f0) [right = of f, graphNT] {F, $\varnothing$, $l$, \textbf{Unlock}};
        \node (rel) [rectangle, dashed, draw, below = of f, CfgInstr] {Release lock};
        \node (end) [below = of rel, CfgInstr] {\texttt{jmp R0}};
        \draw[->] (r) -- (b);
        \draw[->,ifTrue] (b) -- (b0);
        \draw[->,ifTrue] (c) -- (c0);
        \draw[->,ifTrue] (d) -- (d0);
        \draw[->,ifTrue] (e) -- (e0);
        \draw[->,ifTrue] (f) -- (f0);
        \draw[->,ifFalse] (b) -- (c);
        \draw[->,ifFalse] (c) -- (d);
        \draw[->,ifFalse] (d) -- (e);
        \draw[->,ifFalse] (e) -- (f);
        \draw[->,ifFalse] (f) -- (rel);
        \draw[->] (rel) -- (end);
      \end{tikzpicture}
    }\\
    \hspace{\textwidth}
  }
  \caption{An example indirect control-flow operation.  The release
    lock operation is only present if $l=\mathit{held}$.  Not shown: restoring
    the previous value of register {\tt R0}.}
  \label{fig:fix:eg_indirect}
\end{sanefig}

\section{Discussion}

This chapter described how to convert characterisations of bugs, in
the form of \glspl{verificationcondition}, into critical sections and
how those critical sections can be used to build patches which
eliminate the original bug, all without further manual intervention.
The resulting fixes consist of duplicated copies of the buggy code
with the minimal changes necessary to introduce the desired
synchronisation, and so performance will generally be similar to that
of the original program, beyond the necessary loss of concurrency and
lock overheads.  Further, the patch generation algorithm is itself
sufficiently simple that it could plausibly be implemented correctly,
helping to give confidence that the generated fixes will not
themselves introduce additional bugs.

{\Technique}-generated patches do, however, have one serious weakness,
common to all systems which introduce additional synchronisation
without knowing the program's global structure: they can cause
deadlocks.  {\Technique} detects and recovers from these using a
timeout.  This is sufficient to ensure that a fixed program will
always make forward progress (assuming that the unfixed version did
and ignoring certain livelock-related issues), but could potentially
cause a significant loss of performance if it happens too often.  If
necessary, these problems could be mitigated using existing deadlock
aversion techniques such as Gadara~\cite{FFFWang2008} or
Dimmunix~\cite{Jula2008}, or even a simple adaptive timeout mechanism.
I have not found any bugs in real programs where these deadlocks
happen with sufficient frequency to be a practical problem, and so
have not investigated these strategies in detail.

I have now described how {\technique} finds, characterises,
reproduces, and ultimately fixes atomicity violations in its target
class.  In doing so I made several claims about its efficacy and
performance.  The next chapter aims to substantiate these by means of
a series of experiments conducted using {\implementation}, my
implementation of {\technique}, providing quantitative and qualitative
characterisations of its behaviour under a variety of circumstances.

