\subsection{Heuristic simplifications of the {\StateMachines} }
\label{sect:enforce:heuristic_simplify}

\todo{There's some intuition here that the important thing is
  maintaining satisfiability of the verification condition.  Not
  really sure how to make that explicit.}

The crash summaries generated by the main analysis often contain a lot
of redundant information, and this can complicate the process of
enforcing the crash.  The first phase of generating an enforce is
therefore to remove this ancillary information.  Most obviously, all
of the parts of the {\StateMachines} used only to provide hints to the
simplifiers and symbolic execution engine can be dropped:
\state{Assert}, \state{PointsTo}, \state{StartFunction}, and so forth.
This often allows further simplifications by, for instance, making
some of the variables used in the assertions dead, or by making states
which differ only in their calling context more easily unified.

This phase also uses some heuristics to simplify the verification
condition, such as assuming that $x {\times} k = y {\times} k
\Leftrightarrow x = y$ for all constants $k$.  This is not necessarily
true for ordinary integer arithmetic due to integer overflow issues,
but is in practice true often enough to be a sensible assumption.

Next, the R atomic and W atomic parts of the verification condition
can be removed.  These restrict the analysis to only consider the case
where running some combination of the {\StateMachines} atomically
would survive.  This is appropriate when trying to determine
statically whether a concurrency bug might exist, but is unlikely to
be helpful when trying to enforce a concurrency bug.  If R atomic
fails then the read-side is likely to crash without any help from a
concurrent thread, and so the pattern of delays which the enforcer
applies is unlikely to make a great deal of difference either way.
Having the enforcer attempt to check R atomic is therefore rather
pointless.  Likewise, seeing the W atomic constraint fail usually
indicates that the program has a bug, but it is not one which the
enforcer can do anything about.  The analysis therefore re-derives R
atomic and W atomic constraints and simplifies the verification
condition under the assumption that both are true.

Note that this is not quite the same as simply replacing the
verification condition with the crash possible constraint, as the
information in the atomic constraints will have been used to constrain
the paths considered during symbolic execution of the cross-product
{\StateMachine}.  \todo{Should really figure out whether that's
  actually a good thing or not.}

\todo{This suggests another possible validation thing for the eval: do
  something which evaluates R atomic and W atomic instead of trying to
  enforce the HB graph and see how often they fail.  R atomic,
  certainly, should never fail.  W atomic might due to synchronisation
  things, so that might turn out to be less interesting.}

\subsubsection{Removal of redundant clauses}

\todo{Really not convinced that this is actually a good idea in
  practice.  The original justification was making the bugs easier for
  a person to understand, and it sometimes helps here, but it equally
  easily make things worse.  Maybe just kill it.}

These simplifications can sometimes mean that the verification
condition includes constraints on program-level values which are no
longer mentioned anywhere in either of the {\StateMachines}.  These
clauses tend not to provide very much useful information, and so it
makes sense to remove them.  At the same time, it is important not to
remove apparently-redundant variables which mediate between
interesting ones.  For instance, if the verification condition were
$thread1:RBX = thread2:RCX \wedge thread2:RCX = thread2:RDX \wedge
thread2:RCX = 7$, where $thread1:RBX$ and $thread2:RDX$ appear in the
{\StateMachines} but $thread2:RCX$ does not, it would not be
appropriate to remove the references to $thread2:RCX$.  On the other
hand, if the condition were $thread1:RBX = thread2:RDX \wedge
thread2:RCX = 7$ then it would be useful to remove the constraint on
$thread2:RCX$ and produce a verification condition of just
$thread1:RBX = thread2:RDX$.  \todo{Not sure how much I believe that,
  now that I've written it down, but nevermind.  Also, that's a really
  stupid example; come up with a better one.}

At a high level, the idea here is to factor the verification condition
into a conjunction of independent clauses and then eliminate any
clauses which do not constrain the behaviour of the {\StateMachines}.
{\Technique} does this in a very simple way: convert the verification
condition to conjunctive normal form, build an interference graph
whose vertices are variables and which has an edge between variables
whenever those vertices appear together in a clause, and then find all
of the connected components of this graph.  These components are the
independent clauses of the factorisation.  Any which do not mention
any variables which are also mentioned by the {\StateMachines} can be
safely discard. \todo{Ref Gaifman graphs?}

This is not a particularly efficient algorithm, due to the need to
convert to conjunctive normal form, and often takes an intractable
amount of time for complicated verification conditions.  Fortunately,
it is also optional: even when this simplification fails, the
resulting enforcer is still \todo{in some sense} correct, although it
may often be slower or less effective than it otherwise would be.  If
failure of this phase were a problem then it could probably be
improved using, for instance, the techniques discussed in \todo{find
  something to cite.  There must be something; this is a pretty damn
  common problem if you're doing theorem proving, and this cannot be
  the best way of solving it.}

One important subtlety here is the definition of variable.  Some, such
as program registers, are obvious, but others, such as initial-memory
$LD$ expressions are more subtle.  The problem is that $LD(addr)$
expressions depend on the address loaded and it is not always apparent
whether two $LD$ expressions might possibly alias, and hence whether
they should be treated as the same variable.  {\Technique} solves this
problem by segregating the $LD$ expressions into groups which might
alias and treating each such group as a value, so that $LD(addr)$ is
considered to influence $LD(addr')$ if there is any possibility that
$addr$ might equal $addr'$.  This is conservative but safe.

\todo{Maybe mention that testing $addr = addr'$ depends on where
  abouts in the {\StateMachine} the load is mentioned?  Or is that too
  obvious?}

\todo{Also mention that $BadPtr$ expressions get the same sort of
  treatment.}

\todo{HB edges: the input {\StateMachines} don't usually contain any
  HB edge, but we assume that an edge $a \happensBefore b$ is
  mentioned if either $a$ or $b$ are mentioned anywhere.}

\subsubsection{Removal of underspecified clauses}

\todo{This is easier to justify as a preliminary to satisfiability
  checking, rather than a simplification prior to building the
  enforcer, but it is rather useful here.}

In a similar vein, if a variable is never mentioned in the
{\StateMachines} and is mentioned precisely once in the verification
condition then its value is unlikely to be particularly enlightening.
The intuition here is again that a constraint is most likely to be
important when it influences the satisfiability of the verification
condition, and such a single-use variable will very rarely do so.
Alternatively, the single use of the variable can be regarded as its
definition, in which case there is a definition of a variable which is
never used and so the definition can be removed.  These variables are
referred to as underspecified, because the verification condition and
{\StateMachines} do not meaningfully constraint their values.  This
generalises easily to expressions by saying that an expression is
underspecified if the presence of underspecified variables means that
it can be set to anything at all.  The verification condition is, at
this stage, usually a conjunction of clauses, and any clauses which
are underspecified can simply be discarded.

\todo{Not sure that's all that clear.}

