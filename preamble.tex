\usepackage{algpseudocode}
\usepackage{color}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{tabularx}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{amssymb}
\usepackage{paralist}
\usepackage{multirow}
\usepackage{lscape}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{glossaries}
\usepackage{wrapfig}

\newbox\subfigbox             % Create a box to hold the subfigure.
\makeatletter
  \newenvironment{subfloat}% % Create the new environment.
    {\def\caption##1{\gdef\subcapsave{\relax##1}}%
     \let\subcapsave=\@empty % Save the subcaption text.
     \let\sf@oldlabel=\label
     \def\label##1{\xdef\sublabsave{\noexpand\label{##1}}}%
     \let\sublabsave\relax    % Save the label key.
     \setbox\subfigbox\hbox
       \bgroup}%              % Open the box...
      {\egroup                % ... close the box and call \subfigure.
     \let\label=\sf@oldlabel
     \subfigure[\subcapsave]{\box\subfigbox}}%
\makeatother

\usetikzlibrary{arrows,decorations.pathmorphing,decorations.markings,backgrounds,positioning,fit,petri,automata,shapes,petri,patterns}

\pgfdeclarelayer{bg}
\pgfsetlayers{bg,main}

% MGK recommends these formatting settings:

% for hard-bound final submission, use:
\setlength{\oddsidemargin}{4.6mm}     % 30 mm left margin - 1 in
% for soft-bound version and techreport, use instead:
%\setlength{\oddsidemargin}{-0.4mm}    % 25 mm left margin - 1 in
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\topmargin}{-5.4mm}        % 20 mm top margin - 1 in
\setlength{\textwidth}{160mm}         % 20/25 mm right margin
\setlength{\textheight}{247mm}        % 20 mm bottom margin
\setlength{\headheight}{5mm}
\setlength{\headsep}{5mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\renewcommand\baselinestretch{1.2}
\renewcommand\topfraction{.9}
\renewcommand\textfraction{.1}
\renewcommand\floatpagefraction{.8}

% defining the new dimensions
\newlength{\hatchspread}
\newlength{\hatchthickness}
% declaring the keys in tikz
\tikzset{hatchspread/.code={\setlength{\hatchspread}{#1}},
         hatchthickness/.code={\setlength{\hatchthickness}{#1}}}
% setting the default values
\tikzset{hatchspread=8pt,
         hatchthickness=2pt}
% declaring the pattern
\pgfdeclarepatternformonly[\hatchspread,\hatchthickness]% variables
   {diagonal hatch}% name
   {\pgfqpoint{-2\hatchthickness}{-2\hatchthickness}}% lower left corner
   {\pgfqpoint{\dimexpr\hatchspread+2\hatchthickness}{\dimexpr\hatchspread+2\hatchthickness}}% upper right corner
   {\pgfqpoint{\hatchspread}{\hatchspread}}% tile size
   {% shape description
    \pgfsetlinewidth{\hatchthickness}
    \pgfpathmoveto{\pgfqpoint{0pt}{\hatchspread}}
    \pgfpathlineto{\pgfqpoint{\dimexpr\hatchspread+0.15pt}{-0.15pt}}
    \pgfsetstrokecolor{red!20}
    \pgfusepath{stroke}
   }

\newglossaryentry{crashingthread}{
  name = crashing thread,
  description = {The program thread which actually crashed,
    as opposed to the \gls{interferingthread}, which is the
    one which caused the crash.}
}
\newglossaryentry{interferingthread}{
  name = interfering thread,
  description = {The program thread which the \gls{crashingthread}
    raced with, causing the crash which is being investigated.}
}

\newglossaryentry{programmodel}{
  name = program model,
  description = {A database of certain properties of the
    program which are hard to derive from {\StateMachines}.
    This is built by means of static and dynamic analysis
    before the main {\StateMachine} analysis starts.}
}
\newglossaryentry{dynamicaliasingtable}{
  name = dynamic aliasing table,
  description = {A model of the way in which instructions
    which access memory can alias, collected by a dynamic
    analysis.  Part of the \gls{programmodel}.}
}
\newglossaryentry{functionhead}{
  name = function head,
  description = {The first instruction in a function.}
}

\newglossaryentry{alpha}{
  name = {\ensuremath{\alpha}},
  description = {The size of the analysis window.  This is the
    maximum number of instructions which will ever be
    collected into a single {\StateMachine}.}
}

\newacronym{cfg}{CFG}{Control Flow Graph}
\newglossaryentry{controlflowgraph}
{
  name = Control Flow Graph (CFG),
  description = {A directed graph whose nodes are instructions
    of the program and whose edges represent the program's possible
    control flow paths.  These can be either native, in which
    case they represent the program's actual control flow, or
    unrolled, in which case they represent the way in which program
    loops were unrolled to remove cycles.
  }
}

\makeglossaries

\author{Steven Smith}
\title{{\Technique}: Automated techniques for diagnosing, reproducing, and fixing concurrency bugs}
