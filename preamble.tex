\usepackage{algpseudocode}
\usepackage{color}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{tabularx}
\usepackage{rotating}
\usepackage[hang,IT]{subfigure}
\usepackage{amssymb}
\usepackage{paralist}
\usepackage{multirow}
\usepackage{lscape}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{glossaries}
\usepackage{wrapfig}
\usepackage[font={small,it}]{caption}
\usepackage{arydshln}
\usepackage{array}

\renewcommand{\captionlabelfont}{\rm}

\newbox\subfigbox             % Create a box to hold the subfigure.
\makeatletter
  \newenvironment{subfloat}% % Create the new environment.
    {\def\caption##1{\gdef\subcapsave{\relax##1}}%
     \let\subcapsave=\@empty % Save the subcaption text.
     \let\sf@oldlabel=\label
     \def\label##1{\xdef\sublabsave{\noexpand\label{##1}}}%
     \let\sublabsave\relax    % Save the label key.
     \setbox\subfigbox\hbox
       \bgroup}%              % Open the box...
      {\egroup                % ... close the box and call \subfigure.
     \let\label=\sf@oldlabel
     \subfigure[\subcapsave]{\box\subfigbox}}%
\makeatother

\usetikzlibrary{arrows,decorations.pathmorphing,decorations.markings,backgrounds,positioning,fit,petri,automata,shapes,petri,patterns}

\pgfdeclarelayer{bg}
\pgfsetlayers{bg,main}

% MGK recommends these formatting settings:

% for hard-bound final submission, use:
\setlength{\oddsidemargin}{4.6mm}     % 30 mm left margin - 1 in
% for soft-bound version and techreport, use instead:
%\setlength{\oddsidemargin}{-0.4mm}    % 25 mm left margin - 1 in
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\topmargin}{-5.4mm}        % 20 mm top margin - 1 in
\setlength{\textwidth}{160mm}         % 20/25 mm right margin
\setlength{\textheight}{247mm}        % 20 mm bottom margin
\setlength{\headheight}{5mm}
\setlength{\headsep}{5mm}
\setlength{\parindent}{5mm}
\setlength{\parskip}{\medskipamount}
\renewcommand\baselinestretch{1.2}
\renewcommand\topfraction{.9}
\renewcommand\textfraction{.1}
\renewcommand\floatpagefraction{.8}

% defining the new dimensions
\newlength{\hatchspread}
\newlength{\hatchthickness}
% declaring the keys in tikz
\tikzset{hatchspread/.code={\setlength{\hatchspread}{#1}},
         hatchthickness/.code={\setlength{\hatchthickness}{#1}}}
% setting the default values
\tikzset{hatchspread=8pt,
         hatchthickness=2pt}
% declaring the pattern
\pgfdeclarepatternformonly[\hatchspread,\hatchthickness]% variables
   {diagonal hatch}% name
   {\pgfqpoint{-2\hatchthickness}{-2\hatchthickness}}% lower left corner
   {\pgfqpoint{\dimexpr\hatchspread+2\hatchthickness}{\dimexpr\hatchspread+2\hatchthickness}}% upper right corner
   {\pgfqpoint{\hatchspread}{\hatchspread}}% tile size
   {% shape description
    \pgfsetlinewidth{\hatchthickness}
    \pgfpathmoveto{\pgfqpoint{0pt}{\hatchspread}}
    \pgfpathlineto{\pgfqpoint{\dimexpr\hatchspread+0.15pt}{-0.15pt}}
    \pgfsetstrokecolor{red!20}
    \pgfusepath{stroke}
   }

\newglossaryentry{bugenforcer}{
  name = bug enforcer,
  description = {A set of modifications to a program which alters
    the way in which it is scheduled, making a particular
    concurrency-related bug more likely to reproduce.}
}

\newglossaryentry{crashingthread}{
  name = crashing thread,
  description = {The program thread which actually crashed,
    as opposed to the \gls{interferingthread}, which is the
    one which caused the crash.}
}
\newglossaryentry{interferingthread}{
  name = interfering thread,
  description = {The program thread which the \gls{crashingthread}
    raced with, causing the crash which is being investigated.}
}

\newglossaryentry{programmodel}{
  name = program model,
  description = {A database of certain properties of the
    program which are hard to derive from {\StateMachines}.
    This is built by means of static and dynamic analysis
    before the main {\StateMachine} analysis starts.}
}
\newglossaryentry{dynamicaliasingtable}{
  name = dynamic aliasing table,
  description = {A model of the way in which instructions
    which access memory can alias, collected by a dynamic
    analysis.  Part of the \gls{programmodel}.}
}
\newglossaryentry{functionhead}{
  name = function head,
  description = {The first instruction in a function.}
}

\newglossaryentry{analysiswindow}{
  name = analysis window,
  description = {The set of instructions in a given
    thread over which {\technique} will consider alternative instruction
    schedules.  This will contain \gls{alpha} instructions.}
}


\newglossaryentry{alpha}{
  name = {\ensuremath{\alpha}},
  description = {The size of the analysis window.  This is the
    maximum number of instructions which will ever be
    collected into a single {\StateMachine}.}
}

\newglossaryentry{verificationcondition}{
  name = {verification condition},
  description = {An expression over the program state and happens-before
    graph which evaluates to true when a particular bug might
    actually happen.}
}

\newglossaryentry{inferredassumption}{
  name = {inferred assumption},
  description = {The inferred assumption is a condition on the state
    of a program which is satisfied when it lacks non-concurrency bugs.
    It is the conjunction of the \gls{ci-atomic} and \gls{ic-atomic}
    conditions.}
}
\newglossaryentry{ci-atomic}{
  name = {CI atomic},
  description = {The CI atomic condition is the condition necessary
    for the concatenation of the \glslink{crashingthread}{crashing}
    and \glslink{interferingthread}{interfering} {\StateMachines} to
    not crash when run atomically.  See also \gls{ic-atomic}.}
}
\newglossaryentry{ic-atomic}{
  name = {IC atomic},
  description = {The IC atomic condition is the condition necessary
    for the concatenation of the \glslink{interferingthread}{interfering}
    and \glslink{crashingthread}{crashing} {\StateMachines} to
    not crash when run atomically.  See also \gls{ci-atomic}.}
}

\newglossaryentry{crossproduct}{
  name = {cross product},
  description = {The cross-product of two {\StateMachines} is a {\StateMachine}
    which models all of the possible interleavings of the operations
    in the two input {\StateMachines}.}
}
\newglossaryentry{interferingstore}{
  name = {interfering store},
  description = {An interfering store is one which might alias with a
    memory load operation in the \gls{crashingthread}, and hence one
    which might alter the result of the \gls{crashingthread} {\StateMachine}
    if run in parallel with it.}
}

\newglossaryentry{communicatinginstruction}{
  name = {communicating instruction},
  description = {The communicating instructions are those which might
    either influence or be influenced by an operation in the
    \gls{crashingthread}.  This includes all of the
    \glspl{interferingstore}, plus all of the loads which might alias
    with a store in the \gls{crashingthread}.}
}

\newglossaryentry{w-isolation}{
  name = {W-isolation},
  description = {A bug is said to have the W isolation property if
    the flow of information is entirely from the \gls{interferingthread}
    to the \glslink{crashingthread}{crashing} one.  In other words,
    a bug is W-isolated if the \gls{interferingthread} never loads
    from any memory locations which were previously stored to by
    the \gls{crashingthread}.}
}

\newacronym{cfg}{CFG}{Control Flow Graph}
\newglossaryentry{controlflowgraph}
{
  name = Control Flow Graph (CFG),
  description = {A directed graph whose nodes are instructions
    of the program and whose edges represent the program's possible
    control flow paths.  These can be either native, in which
    case they represent the program's actual control flow, or
    unrolled, in which case they represent the way in which program
    loops were unrolled to remove cycles.
  }
}

\makeglossaries

\author{Steven Smith}
\title{{\Technique}: Automated techniques for diagnosing, reproducing, and fixing concurrency bugs}
