\section{Motivation}
Concurrency bugs are becoming more common, don't always have source (abandonware, libraries), so need something which works on binaries

\section{Overview of approach}
\subsection{Pipeline}
Overview of the basic pipeline: find bugs with bug finding more, then instantiate them into an enforcement patch, then analyse the core dump/DRS log to better characterise the bug, and then instantiate a fix.

\subsection{Analysis technique}
Overview of basic analysis technique: building \StateMachines which approximate a fragment of the program and then doing the analysis on that.
Explain that \StateMachines are derived for some specific behaviour which is currently being investigated, and that the simplifications used depend on that.
Explain that the specification of the behaviour must be a simple boolean i.e. the interesting thing either happens or does not happen, but that's usually not an issue because the \StateMachines themselves are reasonably computationally powerful (although not Turing complete), so properties like ``X must never be greater than 5'' can be checked without needing to check properties of X.
Explain that \StateMachines are acyclic and finite, and hence executions are also finite; makes analysis much, much easier.
Explain that they can cross function boundaries and can include fragments from multiple program threads.
Explain that each \StateMachine corresponds to some possible point in the program execution (defined by a set of suffixes of stacks, such that at least one thread must match each of the suffixes), and that if you have a snapshot of the program in that state you can interpret the \StateMachine to predict whether the program is going to experience the behaviour which is being investigated.

This is probably a good place to give some examples and a very informal semantics; the full semantics will wait until later.

\section{Background}
All the bits you need to understand before reading the rest of the dissertation.
Fairly dumb summary of a little bit of related work.
